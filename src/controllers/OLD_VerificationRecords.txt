import { Button } from "@chakra-ui/react";
import { ethers } from "ethers";
import { useState } from "react";
import { useContractRead, useContractReads, useContractWrite, usePrepareContractWrite, useWaitForTransaction } from "wagmi";
import useVerificationRegistryData from "../hooks/useVerificationRegistryData";
import { VerificationInfoView, VerifierInfoView } from "../views";

const VerificationRecordsController = () => {

    /**
     * State
     */


    const [verifierAddress, setVerifierAddress] = useState("");
    const [uuid, setUuid] = useState("");
    const [subjectAddress, setSubjectAddress] = useState("");

    const [record_uuid, setRecordUuid] = useState("");

    /**
     * Contract Data
     */


    const [vr_address, vr_abi] = useVerificationRegistryData();
    const contract = {
        addressOrName: vr_address,
        contractInterface: vr_abi,
    }

    /**
     * Contract Reads
     */

    // Take care! This read function returns a Result and not a Result[]
    const { data: verificationRecords1 } = useContractRead({
        ...contract,
        functionName: 'getVerification',
        args: [uuid]
    });

    const { data: verificationRecords2 } = useContractRead({
        ...contract,
        functionName: 'getVerificationsForSubject',
        args: [subjectAddress]
    });

    const { data: verificationRecords3 } = useContractRead({
        ...contract,
        functionName: 'getVerificationsForVerifier',
        args: [verifierAddress],
    });

    let verificationRecords;
    if (uuid) {
        // this is a Result so we have to wrap it in an array.
        verificationRecords = [verificationRecords1];
    }
    if (subjectAddress) {
        verificationRecords = verificationRecords2;
    }
    if (verifierAddress) {
        verificationRecords = verificationRecords3;
    }

    /**
     * Contract Writes
     */

    // REVOKE
    const { config: revokeConfig, error: prepareRevokeError, isError: isPrepareRevokeError } = usePrepareContractWrite({
        ...contract,
        functionName: 'revokeVerification',
        args: [record_uuid],
    });

    const { data: revokeData, error: revokeError, isError: isRevokeError, write: revokeWrite } = useContractWrite(revokeConfig);

    // using the useWaitForTransaction we can show feedback on the status of the transaction
    const { isLoading: isLoadingRevoke, isSuccess: isSuccessRevoke } = useWaitForTransaction({
        hash: revokeData?.hash,
    });

    function handleClickRevoke() {
        revokeWrite?.();
    }

    // REMOVE

    const { config: removeConfig, error: prepareRemoveError, isError: isPrepareRemoveError } = usePrepareContractWrite({
        ...contract,
        functionName: 'removeVerification',
        args: [record_uuid],
    });

    const { data: removeData, error: removeError, isError: isRemoveError, write: removeWrite } = useContractWrite(removeConfig);

    // using the useWaitForTransaction we can show feedback on the status of the transaction
    const { isLoading: isLoadingRemove, isSuccess: isSuccessRemove } = useWaitForTransaction({
        hash: removeData?.hash,
    });

    function handleClickRemove() {
        removeWrite?.();
    }

    return <VerificationInfoView 
        verificationRecords={verificationRecords} 
        setUuid={setUuid} 
        setSubjectAddress={setSubjectAddress} 
        setVerifierAddress={setVerifierAddress} 
        setRecordUuid={setRecordUuid}
        handleClickRevoke={handleClickRevoke}
        isLoadingRevoke={isLoadingRevoke}
        isSuccessRevoke={isSuccessRevoke}
        isPrepareRevokeError={isPrepareRevokeError}
        isRevokeError={isRevokeError}
        prepareRevokeError={prepareRevokeError}
        revokeError={revokeError}
        handleClickRemove={handleClickRemove}
        isLoadingRemove={isLoadingRemove}
        isSuccessRemove={isSuccessRemove}
        isPrepareRemoveError={isPrepareRemoveError}
        isRemoveError={isRemoveError}
        prepareRemoveError={prepareRemoveError}
        removeError={removeError}
    />
};

export default VerificationRecordsController;